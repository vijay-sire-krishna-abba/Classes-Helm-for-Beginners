There were some significant changes when Helm 3 was released compared to Helm 2. And when you browse through charts and blogs online, you may come across either of these versions. So it is important to understand the differences between them. Now let's look at a brief history of Helm. Helm 1.0 was first released in February 2016. Helm 2.0 in November 2016, and Helm 3.0 in November 2019. Now since the initial launch in 2016, the project has matured and it got better and better. The improvements were also made possible by the fact that Kubernetes itself was improving. So Helm had more tools at its disposal, it could leverage right off of Kubernetes. In our lessons, we'll use Helm 3, which has a simpler and better design than the previous Helm 2 and is also a bit smarter. Since Helm 2 was around for a few years, a lot of users had already been using it. But there are several important changes made when Helm 3 was launched. So let's take a look at the differences between them. Helm has a CLI client installed on your local machine that helps you perform Helm specific actions against your Kubernetes cluster. When Helm 2 was around, Kubernetes lacked features such as role-based access control and custom resource definitions. To allow Helm to do its magic, an extra component called Tiller had to be installed in the Kubernetes cluster. So whenever you wanted to perform a Helm specific operation, your Helm client communicated with Tiller that was running on some server. Tiller in turn communicated with Kubernetes and proceeded to take actions to make whatever you requested happen. So Tiller was the middleman, so to speak. Besides the fact that an extra component sitting between you and Kubernetes adds complexity, there were also some security concerns. By default, Tiller was running in God mode, or otherwise said it had the privileges to do anything that it wanted. This was good since it allowed it to make whatever changes necessary in your Kubernetes cluster to install your charts. But this was bad since it allowed any user with Tiller access to do whatever they wanted in the cluster. After cool stuff like role-based access control and custom resource definitions appeared in Kubernetes, the need for Tiller decreased. And so it was removed entirely in Helm 3. Now there's nothing sitting between Helm and the cluster. Furthermore, with RBAC security is much improved and any user can be limited in what they can do with Helm. Before you had to set these limits in Tiller. And that was not the best option. But with RBAC built from ground up to fine tune user permissions in Kubernetes, it's now straightforward to do. As far as Kubernetes is concerned, it doesn't matter if the user is trying to make changes within the cluster with kubectl or with Helm commands. The user requesting the changes has the same RBAC allowed permissions, whatever tool they use. So that's a big difference between Helm 2 and 3. Helm 2 had Tiller and Helm 3 simplifies integration with Kubernetes by removing Tiller. The next big difference is a three-way strategic merge patch. The name might sound intimidating, but don't worry. At the end of this section, we'll see it's actually a simple but very smart thing that can prove quite useful. Now Helm has something like a snapshot feature. Here's an example, you can use a chart to install a full-blown WordPress website. This will create revision number one for this install. Then if you change something, for example, you upgrade to a newer chart to upgrade your WordPress install, you will arrive at revision number two. These revisions can be considered something like snapshots, the exact state of a Kubernetes package at that moment in time. If there's a need, you can return to revision number one, do a rollback. This would get your package app to the same state it was when you first installed your chart. New revisions are created whenever important changes are done with the Helm command. For example, when we first install a package, a revision one is created. Then when we upgrade that package, a new revision appears, there's revision two in this case. And even when we roll back, a new revision is created revision three. So that's pretty straightforward. Helm 2 was less sophisticated when it came to how we did such rollbacks. And when a rollback command is issued, Helm compares the current chart, which is the chart that has the WordPress image 5.8. And it compares with the previous chart, which is the chart that has a WordPress 4.8 image in it and realizes that they are different. So it applies the original chart to revert the WordPress image to 4.8. Now let's look at another example. Save install a WordPress deployment using a Helm chart, which creates revision one just like before, then a user manually goes in and updates the application image using the kubectl set image command. So the application gets updated. And this is done instead of doing the upgrade through Helm. And this does not create a new revision in Helm because the change was not performed through Helm. When we now roll back, what happens? As before, Helm compares the current revision with the previous version. Since there is only one revision, Helm does not detect any changes. And so it does not roll back or make any changes to the deployment. So Helm 2 compares the current chart with the previous chart to identify the difference between revisions to make a rollback decision. And in this case, it doesn't help us because the manual change that the user made is still active. Helm 3, on the other hand, is more intelligent. It compares the chart currently in use if we had created a revision, that is which we didn't the chart we want to revert to. And also the live state how our Kubernetes objects currently look like their declarations in the YAML form. This is where that fancy three-way strategic merge patch name comes from. By also looking at the live state, it notices that the image version in live is 5.8. But the image in revision one that we want to revert to is at 4.8. So it makes necessary changes to come back to the original state. Now besides rollbacks, there are also things like upgrades to consider, where Helm 2 was also lacking, for example, say you install a chart, but then you make some changes to some of the Kubernetes objects installed. It all works nicely until you perform an upgrade. Helm 2 looks at the old chart, and then the new chart that you want to upgrade to. And all your changes will be lost since they don't exist in the old chart or the new chart. But Helm 3, as mentioned, looks at the charts, and also at the live state, and it notices that you added some stuff of your own. So it performs the upgrade while preserving anything that you might have added. Well, that's all for this lecture, and I will see you in the next one.