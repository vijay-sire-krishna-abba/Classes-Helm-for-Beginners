Let's start with writing our own Helm charts first. Helm charts are incredibly versatile, and they can automate almost any kind of Kubernetes package installation that we can think of. In a way, they're similar to installation wizards on operating systems. And installation wizard, besides extracting the application files and directories can also add relevant shortcuts to the desktop configure the application to launch when the operating system starts up, install additional libraries that are needed and so on. The same is true for Helm Charts. Although charts are technically not programs, they can act like programs. Besides just installing various Kubernetes objects to get our app up and running, they can do some extra stuff too. For example, we can write the chart in such a way that whenever we do a Helm upgrade, a database can be automatically backed up before that happens. So we have a way to restore data from backup in case something goes wrong. And that's just one small example. We will look at those kinds of complex setups with hooks and everything towards the end of this section. It can be overwhelming to think about, like a lot of a million things a chart can do at this point. So let's start with something simple and learn the important bits and pieces one by one. So let's start by looking at how to create a Helm chart from scratch. Let's use the example of a simple Hello World application. We have a deployment with the nginx image with two replicas. And we have a service to expose this application. Super simple. Let's see how we can create a Helm chart from this. Earlier, we learned that a Helm chart is a directory with a specific structure with the templates directory and the other supporting files like the values.yaml, the Chart.yaml, license, README, etc. So our goal is to create a directory structure first, something like this, but you don't have to do that yourself manually. You could run the helm create command and specify a chart name to create a chart structure. And this creates a skeleton structure of a Helm chart. So now you just have to go in and modify these files, or add the relevant files to the templates or charts directory. Now you'll see the chart.yaml file already has some sample data in it, it has the name already set to nginx-chart, because that's what we gave in the command line, and a sample description and some sample values for versions and app versions. Now let's assume the following scenario, let's assume that we are building this for our company. And we want other employees or other users, users that use it to have some basic information about the chart. So we'll modify the description and add an email at the end under the maintenance section. So people can contact us if they have any questions. And feel free to modify the other details and add other properties to it, such as the home, the URL to the home directory, or a path to the icon, etc., as required. Next is the templates directory; it already has some files that are samples. And these are samples automatically created by Helm create command. For now, we will just get rid of these and just work with the files that we already have for our application, because our requirement is pretty simple and straightforward. Okay, so we now have an empty templates directory. And our first goal is to move the files that we already have for our application, the deployment file and the service YAML file into this directory. And to be honest, this should be it. Once we place the relevant files in the templates directory, our Helm chart technically should be ready to go. Our chart is now ready to be installed using the Helm install command. However, note that these files in the templates folder have all static values in it. For example, if you look at the name of the deployment, or the number of replicas or the name of containers, they're all statically defined to Hello World, for example. Now, what could be the problem with that? Imagine we install the Helm chart with this using the Helm install command, we give the release a name, Hello World one, and point to the nginx chart directory that we just created, it installs the chart and creates a deployment. The deployment is named Hello World. This is because the template file has named Hello World defined in it. Now what happens when you try to install another release of the same chart? It fails with the error message that says a deployment with the name Hello World already exists. And of course, as you can see, this is because the deployment name is static and is defined statically in the deployment.yaml file. And every time that we are installing a new release using the helm install command, it's simply trying to create the same deployment with the same name. So it must have different names each time you install a helm chart. So how do we solve this? We templatize the name of the deployment, we use helm's templating language to basically tell Helm that the name of this deployment should be based on how the user chose to name his or her release. So release.name becomes Hello, world dash one, and the name of the deployment becomes Hello, world one dash nginx. So let's take a closer look at that template. Now we templatize something by adding something between the two curly brackets. This is called the template directory. And it's not something very specific to Helm. It is in fact the Go template language that Go programming languages, template language within the curly brackets is where we specify the path to the objects that we'd like to access. It starts with a dot, the dot refers to the root level or top-level scope. We'll talk more about scopes in the upcoming lectures. The release name in this case is the release name that we have specified in the helm install command. So when we run the helm install command, the template directive is replaced by the release name to form hello-dash world-dash-one-dash-nginx. So that's how templating works. Now similar to release name, there are other objects as well such as release.name, release.namespace, release.isUpgrade, revision, service, etc. Or you can refer to any values from the chart.yaml file that we created, such as chart name itself, or the API version that we've defined in the chart.yaml file, or the version or type keywords, home, etc. Or even details of the Kubernetes cluster itself with the capabilities objects such as the kubeVersion, or the set of versions of resources available on the cluster, or the helm version and such. And anything that starts with the values is something that refers to the properties defined in the values.yaml file. And this could be any number of values defined in the values.yaml file. And currently there are two. Now one other thing to note here is the difference in case convention for the first three objects, release, chart, and capabilities. The second part after the dot all starts with a capital letter, such as name, namespace, upgrade, and others. However, if you look at values, you'll see this starts with a small case. So why is that? These are case sensitive. So it is important to be careful with the case you use. The first three are built-in objects. And as such, they must follow the capital letter naming convention. Everything under values is user-defined. That is whatever the user defines in the values.yaml file. So the users are free to follow whatever naming convention that they'd like to follow in the values.yaml file. In this case, these values follow a small case letter. And so you must use whatever it is that is defined in the values.yaml file. Coming back to our example, if we create a release called Hello World 1 and another called Hello World 2, the first one will name the deployment Hello World 1 nginx while the second one will call it Hello World 2 nginx. And we now have guaranteed unique names. Now remember to do the same for the services or any other objects that you create as part of your Helm chart. We should follow similar techniques for all Kubernetes objects that must have unique values or names. Helm does not allow us to install two releases with the same name. So by basing the names of our Kubernetes objects on the release name, we can be sure that our charts can never create two objects with the same name. Furthermore, when we later explore our objects, seeing something called release 5-PVC or something will quickly help us identify to which release this object belongs. So whatever value you think shouldn't be hard coded should be templatized. In this case, the replicas and image names could be values that we need to allow the user using our charts to customize. So we can templatize them by using the values.yaml replica count and values .yaml image template directive like this. So anything defined as values should either be passed through the values option, or the set option while installing Helm chart, or be defined in the values.yaml file like this. So let's take a closer look at the value defined for image. Since it's text, we could access it within the deployment.yaml file as values.image. Now, image could have an image name and a version number, as well as other properties such as pull policy, etc. So we can either write it as image_repository, image_pull_policy or image_tag. But a better way and the right way to do it is to write it as a dictionary like this. This way, we can refer to the image name as values.image.repository. So values tells the values from the values.yaml file. The image is the image dictionary within the values .yaml file. And repository is the name of the repository within the image dictionary. So that's how the template directive is formed when we work with dictionaries. And if we want to add the tag on then we add the tag using the same format values.image.tag like this. So the image repository part becomes nginx. And the image tag part becomes 1.16.0. And together they form the complete value with a colon in between. Well, that's how you define a dictionary in the values file and use it in a template. So to summarize, when we install a Helm chart, Helm uses the files in the templates directory, and then combines it with the information about the releases such as the release name and any other information, the data stored in the values.yaml file, and the chart details to form the final versions of manifest files, as seen here on the right to deploy resources on Kubernetes. Now apart from these, it also refers to any other object that are available, such as the Kubernetes cluster itself. So there may be some data that is pulled from the Kubernetes cluster itself, and any other objects that are available to be used in a Helm template. Well, that's all for this lecture, and I will see you in the next one.